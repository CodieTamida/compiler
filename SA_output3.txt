Token: Separator            Lexeme: $
  <Rat24S> -> <Opt Function Definitions>
  <Opt Function Definitions> -> <Function Definitions>
  <Function Definitions> -> <Function> <Function Definitions Prime>
Token: Keyword              Lexeme: function
  <Function> -> function <Identifier> ( <Opt Parameter List> ) <Opt Declaration List> <Body>
Token: Identifier           Lexeme: this_one
Token: Separator            Lexeme: (
  <Opt Parameter List> -> <Parameter List>
  <Parameter List> -> <Parameter> <Parameter Prime> 
  <Parameter> -> <IDs> <Qualifier>
Token: Identifier           Lexeme: a
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Keyword              Lexeme: integer
  <Qualifier> -> integer
Token: Separator            Lexeme: ,
  <Parameter Prime> -> , <Parameter List>
  <Parameter List> -> <Parameter> <Parameter Prime> 
  <Parameter> -> <IDs> <Qualifier>
Token: Identifier           Lexeme: b
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Keyword              Lexeme: boolean
  <Qualifier> -> boolean
Token: Separator            Lexeme: ,
  <Parameter Prime> -> , <Parameter List>
  <Parameter List> -> <Parameter> <Parameter Prime> 
  <Parameter> -> <IDs> <Qualifier>
Token: Identifier           Lexeme: c
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: d
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Keyword              Lexeme: real
  <Qualifier> -> real
  <Parameter Prime> -> ε
Token: Separator            Lexeme: )
  <Opt Declaration List> -> ε
Token: Separator            Lexeme: {
  <Body> -> { <Statement List> }
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: purple
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: a
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Identifier           Lexeme: c
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
Token: Operator             Lexeme: /
  <Term Prime> -> / <Factor> <Term Prime>
Token: Identifier           Lexeme: d
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: scan
  <Statement> -> <Scan>
  <Scan> -> scan ( <IDs> );
Token: Separator            Lexeme: (
Token: Identifier           Lexeme: a
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: b
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: c
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: d
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: )
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: print
  <Statement> -> <Print>
  <Print> -> print ( <Expression> );
Token: Separator            Lexeme: (
Token: Identifier           Lexeme: a
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: return
  <Statement> -> <Return>
  <Return> -> return <Return Prime>
  <Return Prime> -> <Expression> ;
Token: Identifier           Lexeme: purple
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> ε
Token: Separator            Lexeme: }
  <Function Definitions Prime> -> <Function Definitions>
  <Function Definitions> -> <Function> <Function Definitions Prime>
Token: Keyword              Lexeme: function
  <Function> -> function <Identifier> ( <Opt Parameter List> ) <Opt Declaration List> <Body>
Token: Identifier           Lexeme: multi
Token: Separator            Lexeme: (
  <Opt Parameter List> -> <Parameter List>
  <Parameter List> -> <Parameter> <Parameter Prime> 
  <Parameter> -> <IDs> <Qualifier>
Token: Identifier           Lexeme: p1
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: p2
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Keyword              Lexeme: real
  <Qualifier> -> real
Token: Separator            Lexeme: ,
  <Parameter Prime> -> , <Parameter List>
  <Parameter List> -> <Parameter> <Parameter Prime> 
  <Parameter> -> <IDs> <Qualifier>
Token: Identifier           Lexeme: x
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: y
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: z
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Keyword              Lexeme: boolean
  <Qualifier> -> boolean
  <Parameter Prime> -> ε
Token: Separator            Lexeme: )
  <Opt Declaration List> -> <Declaration List>
  <Declaration List> -> <Declaration> ;
  <Declaration> -> <Qualifier> <IDs>
Token: Keyword              Lexeme: integer
  <Qualifier> -> integer
Token: Identifier           Lexeme: helper
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: ;
  <Declaration List Prime> -> ε
Token: Separator            Lexeme: {
  <Body> -> { <Statement List> }
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: sum
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: p1
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Identifier           Lexeme: p2
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: diff
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: sum
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: -
  <Expression Prime> -> - <Term> <Expression Prime>
Token: Identifier           Lexeme: y
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: multi
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: diff
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Identifier           Lexeme: sum
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Integer              Lexeme: 30
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: if
  <Statement> -> <If>
  <If> if ( <Condition> ) <Statement> <If Prime>
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: multi
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: ==
  <Relop> -> ==
Token: Identifier           Lexeme: x
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Identifier           Lexeme: z
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Keyword              Lexeme: true
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> true
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: else
  <If Prime> -> else <Statement> endif
Token: Identifier           Lexeme: z
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Keyword              Lexeme: false
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> false
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: endif
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: return
  <Statement> -> <Return>
  <Return> -> return <Return Prime>
  <Return Prime> -> <Expression> ;
Token: Identifier           Lexeme: z
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> ε
Token: Separator            Lexeme: }
  <Function Definitions Prime> -> <Function Definitions>
  <Function Definitions> -> <Function> <Function Definitions Prime>
Token: Keyword              Lexeme: function
  <Function> -> function <Identifier> ( <Opt Parameter List> ) <Opt Declaration List> <Body>
Token: Identifier           Lexeme: random
Token: Separator            Lexeme: (
  <Opt Parameter List> -> <Parameter List>
  <Parameter List> -> <Parameter> <Parameter Prime> 
  <Parameter> -> <IDs> <Qualifier>
Token: Identifier           Lexeme: n
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Keyword              Lexeme: integer
  <Qualifier> -> integer
  <Parameter Prime> -> ε
Token: Separator            Lexeme: )
  <Opt Declaration List> -> ε
Token: Separator            Lexeme: {
  <Body> -> { <Statement List> }
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: if
  <Statement> -> <If>
  <If> if ( <Condition> ) <Statement> <If Prime>
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: n
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: <
  <Relop> -> <
Token: Integer              Lexeme: 2
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Keyword              Lexeme: return
  <Statement> -> <Return>
  <Return> -> return <Return Prime>
  <Return Prime> -> <Expression> ;
Token: Keyword              Lexeme: false
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> false
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: endif
  <If Prime> -> endif
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: if
  <Statement> -> <If>
  <If> if ( <Condition> ) <Statement> <If Prime>
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: n
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: ==
  <Relop> -> ==
Token: Integer              Lexeme: 2
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Keyword              Lexeme: return
  <Statement> -> <Return>
  <Return> -> return <Return Prime>
  <Return Prime> -> <Expression> ;
Token: Keyword              Lexeme: true
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> true
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: endif
  <If Prime> -> endif
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: if
  <Statement> -> <If>
  <If> if ( <Condition> ) <Statement> <If Prime>
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: mod
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
Token: Separator            Lexeme: (
Token: Identifier           Lexeme: n
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: i
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: )
  <Factor> -> <Identifier> ( <IDs> )
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: ==
  <Relop> -> ==
Token: Integer              Lexeme: 0
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Keyword              Lexeme: return
  <Statement> -> <Return>
  <Return> -> return <Return Prime>
  <Return Prime> -> <Expression> ;
Token: Keyword              Lexeme: false
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> false
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: endif
  <If Prime> -> endif
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: while
  <Statement> -> <While>
  <While> -> while ( <Condition> ) <Statement> endwhile
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: i
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
Token: Operator             Lexeme: *
  <Term Prime> -> * <Factor> <Term Prime>
Token: Identifier           Lexeme: i
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: <=
  <Relop> -> <=
Token: Identifier           Lexeme: n
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Separator            Lexeme: {
  <Statement> -> <Compound>
  <Compound> -> { <Statement List> }
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: if
  <Statement> -> <If>
  <If> if ( <Condition> ) <Statement> <If Prime>
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: mod
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
Token: Separator            Lexeme: (
Token: Identifier           Lexeme: n
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: i
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: )
  <Factor> -> <Identifier> ( <IDs> )
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: ==
  <Relop> -> ==
Token: Integer              Lexeme: 0
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Identifier           Lexeme: prime
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Keyword              Lexeme: false
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> false
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: else
  <If Prime> -> else <Statement> endif
Token: Identifier           Lexeme: i
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: i
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Integer              Lexeme: 2
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: endif
  <Statement List Prime> -> ε
Token: Separator            Lexeme: }
Token: Keyword              Lexeme: endwhile
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: return
  <Statement> -> <Return>
  <Return> -> return <Return Prime>
  <Return Prime> -> <Expression> ;
Token: Identifier           Lexeme: prime
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> ε
Token: Separator            Lexeme: }
  <Function Definitions Prime> -> ε
Token: Separator            Lexeme: $
  <Rat24S> -> <Opt Declaration List>
  <Opt Declaration List> -> <Declaration List>
  <Declaration List> -> <Declaration> ;
  <Declaration> -> <Qualifier> <IDs>
Token: Keyword              Lexeme: integer
  <Qualifier> -> integer
Token: Identifier           Lexeme: trememdous
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: ;
  <Declaration List Prime> -> <Declaration>
  <Declaration List> -> <Declaration> ;
  <Declaration> -> <Qualifier> <IDs>
Token: Keyword              Lexeme: real
  <Qualifier> -> real
Token: Identifier           Lexeme: fantastic
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: ;
  <Declaration List Prime> -> <Declaration>
  <Declaration List> -> <Declaration> ;
  <Declaration> -> <Qualifier> <IDs>
Token: Keyword              Lexeme: boolean
  <Qualifier> -> boolean
Token: Identifier           Lexeme: maybetrue
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: ;
  <Declaration List Prime> -> ε
Token: Separator            Lexeme: $
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: p
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Integer              Lexeme: 56
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: adding
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Integer              Lexeme: 87
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: switch
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Keyword              Lexeme: false
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> false
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: bad_switch
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Keyword              Lexeme: true
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> true
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: print
  <Statement> -> <Print>
  <Print> -> print ( <Expression> );
Token: Separator            Lexeme: (
Token: Identifier           Lexeme: this
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Identifier           Lexeme: that
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: scan
  <Statement> -> <Scan>
  <Scan> -> scan ( <IDs> );
Token: Separator            Lexeme: (
Token: Identifier           Lexeme: things
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: purple
  <IDs> -> <Identifier> <IDs Prime>
Token: Separator            Lexeme: ,
  <IDs Prime> -> , <IDs>
Token: Identifier           Lexeme: strawberry
  <IDs> -> <Identifier> <IDs Prime>
  <IDs Prime> -> ε
Token: Separator            Lexeme: )
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Separator            Lexeme: {
  <Statement> -> <Compound>
  <Compound> -> { <Statement List> }
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: a
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: b
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Identifier           Lexeme: z
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: helper
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Integer              Lexeme: 87
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Integer              Lexeme: 68
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> ε
Token: Separator            Lexeme: }
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: while
  <Statement> -> <While>
  <While> -> while ( <Condition> ) <Statement> endwhile
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: d
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: ==
  <Relop> -> ==
Token: Keyword              Lexeme: true
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> true
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Separator            Lexeme: {
  <Statement> -> <Compound>
  <Compound> -> { <Statement List> }
  <Statement List> -> <Statement> <Statement List Prime>
Token: Identifier           Lexeme: a
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: b
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
Token: Operator             Lexeme: +
  <Expression Prime> -> + <Term> <Expression Prime>
Token: Identifier           Lexeme: z
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
  <Statement List Prime> -> <Statement List>
  <Statement List> -> <Statement> <Statement List Prime>
Token: Keyword              Lexeme: if
  <Statement> -> <If>
  <If> if ( <Condition> ) <Statement> <If Prime>
Token: Separator            Lexeme: (
  <Condition> -> <Expression> <Relop> <Expression>
Token: Identifier           Lexeme: a
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Operator             Lexeme: >
  <Relop> -> >
Token: Integer              Lexeme: 0
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: )
Token: Identifier           Lexeme: a
  <Statement> -> <Assign>
  <Assign> -> <Identifier> = <Expression> ;
Token: Operator             Lexeme: =
Token: Identifier           Lexeme: a
  <Expression> -> <Term> <Expression Prime>
  <Term> -> <Factor> <Term Prime>
  <Factor> -> <Identifier> 
Token: Operator             Lexeme: /
  <Term Prime> -> / <Factor> <Term Prime>
Token: Integer              Lexeme: 2
  <Factor> -> <INTEGER>
  <Term Prime> -> ε
  <Expression Prime> -> ε
Token: Separator            Lexeme: ;
Token: Keyword              Lexeme: endif
  <If Prime> -> endif
  <Statement List Prime> -> ε
Token: Separator            Lexeme: }
Token: Keyword              Lexeme: endwhile
  <Statement List Prime> -> ε
Token: Separator            Lexeme: $
